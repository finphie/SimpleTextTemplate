using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using SimpleTextTemplate.Generator.Extensions;
using SimpleTextTemplate.Generator.Specs;
using static SimpleTextTemplate.Generator.Specs.TemplateWriterWriteType;

namespace SimpleTextTemplate.Generator;

/// <summary>
/// ソースコードを生成します。
/// </summary>
static class Emitter
{
    static readonly string FullName = typeof(TemplateGenerator).FullName;
    static readonly string Version = typeof(TemplateGenerator).Assembly.GetName().Version.ToString();

    /// <summary>
    /// <see cref="TemplateGenerator"/>で使用するソースコードを生成します。
    /// </summary>
    /// <param name="context">インクリメンタルソースジェネレーターで使用するコンテキスト</param>
    /// <param name="infoList">インターセプター情報のリスト</param>
    public static void Emit(SourceProductionContext context, ImmutableArray<InterceptInfo> infoList)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        var builder = new StringBuilder();
        builder.AppendLine($$"""
            // <auto-generated/>
            #pragma warning disable

            namespace SimpleTextTemplate.Generator
            {
                [global::System.CodeDom.Compiler.GeneratedCode("{{FullName}}", "{{Version}}")]
                file static class Intercept
                {
            """);

        for (var i = 0; i < infoList.Length; i++)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var (interceptsLocationInfo, template, writerType, contextTypeName) = infoList[i]!;

            if (i != 0)
            {
                builder.AppendLine();
            }

            builder.AppendLine($$"""
                        [global::System.Runtime.CompilerServices.InterceptsLocation(@"{{interceptsLocationInfo.FilePath}}", {{interceptsLocationInfo.Line}}, {{interceptsLocationInfo.Column}})]
                        public static void Write{{i}}(this ref {{writerType}} writer, string _{{(string.IsNullOrEmpty(contextTypeName) ? string.Empty : $", in {contextTypeName} context")}})
                        {
                """);

            foreach (var (methodType, value) in template)
            {
                context.CancellationToken.ThrowIfCancellationRequested();
                builder.AppendLine($"            writer.{GetWriteMethodName(methodType)}({GetValue(methodType, value, contextTypeName)});");
            }

            builder.AppendLine("        }");
        }

        builder.AppendLine($$"""
                }
            }
            
            namespace System.Runtime.CompilerServices
            {
                [global::System.CodeDom.Compiler.GeneratedCode("{{FullName}}", "{{Version}}")]
                [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute(string filePath, int line, int column) : global::System.Attribute;
            }
            """);

        context.AddSource("SimpleTextTemplate.Generated.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    static string GetWriteMethodName(TemplateWriterWriteType type)
    {
        return type switch
        {
            WriteConstantLiteral or WriteLiteral or WriteStaticLiteral => "WriteLiteral",
            WriteString or WriteStaticString => "WriteString",
            WriteEnum or WriteStaticEnum => "WriteEnum",
            WriteValue or WriteStaticValue => "WriteValue",
            _ => throw new InvalidOperationException()
        };
    }

    static string GetValue(TemplateWriterWriteType type, string value, string? contextTypeName)
    {
        Debug.Assert(
            !(contextTypeName is null && type is WriteStaticLiteral or WriteStaticString or WriteStaticValue),
            $"{nameof(contextTypeName)}がnullかつ静的識別子の場合、コンテキストクラス名が必要となります。");

        return type switch
        {
            WriteConstantLiteral => value.ToUtf8Literal(),
            WriteLiteral or WriteString or WriteEnum or WriteValue => $"global::System.Runtime.CompilerServices.Unsafe.AsRef(in context).@{value}",
            WriteStaticLiteral or WriteStaticString or WriteStaticEnum or WriteStaticValue => $"{contextTypeName}.@{value}",
            _ => throw new InvalidOperationException()
        };
    }
}
